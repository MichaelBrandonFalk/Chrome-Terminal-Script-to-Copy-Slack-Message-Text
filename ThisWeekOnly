(() => {
  // Stop any prior run
  if (window.slackDump && window.slackDump.running) {
    try { window.slackDump.stop(); } catch {}
  }

  const WEEK_STARTS_MONDAY = true;

  const now = new Date();
  const startBoundary = new Date(now);
  const day = startBoundary.getDay(); // 0=Sun,1=Mon,...
  const offset = WEEK_STARTS_MONDAY ? (day + 6) % 7 : day;
  startBoundary.setDate(startBoundary.getDate() - offset);
  startBoundary.setHours(0, 0, 0, 0); // week start 12:00am local time

  const CONFIG = {
    maxRunMs: 6 * 60 * 1000,
    stepWaitMs: 850,
    scrollPx: 1400,
    filePrefix: "slack_this_week",
    olderStreakToStop: 5,
  };

  const STATE = {
    running: true,
    stopRequested: false,
    startedAt: Date.now(),
    steps: 0,
    olderStreak: 0,
    records: new Map(), // key -> { user, text, tsMs }
  };

  const nativeWindowStop = window.stop && window.stop.bind(window);
  window.__nativeWindowStop = nativeWindowStop;

  const controller = new AbortController();
  const { signal } = controller;

  const sleep = (ms) =>
    Promise.race([
      new Promise((r) => setTimeout(r, ms)),
      new Promise((r) => signal.addEventListener("abort", r, { once: true })),
    ]);

  const sanitize = (s) => (s || "").replace(/\s+/g, " ").trim();

  const pickFirstText = (root, selectors) => {
    for (const sel of selectors) {
      const el = root.querySelector(sel);
      const txt = sanitize(el && (el.textContent || el.innerText));
      if (txt) return txt;
    }
    return "";
  };

  const findScroller = () => {
    const candidates = Array.from(document.querySelectorAll('[data-qa="slack_kit_scrollbar"]'));
    let best = null;
    let bestScore = -1;

    for (const el of candidates) {
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      const scrollable = el.scrollHeight > el.clientHeight + 5;
      const score = (scrollable ? 1000 : 0) + count;
      if (score > bestScore) {
        best = el;
        bestScore = score;
      }
    }

    if (best) return best;

    const divs = Array.from(document.querySelectorAll("div"));
    best = null;
    bestScore = -1;
    for (const el of divs) {
      if (el.scrollHeight <= el.clientHeight + 50) continue;
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      if (!count) continue;
      if (count > bestScore) {
        best = el;
        bestScore = count;
      }
    }
    return best;
  };

  const getTsMs = (msg, fallbackTsMs) => {
    const timeEl =
      msg.querySelector('time[datetime]') ||
      msg.querySelector('[data-qa="message_timestamp"] time[datetime]') ||
      msg.querySelector('a.c-timestamp time[datetime]');

    const dt = timeEl && timeEl.getAttribute("datetime");
    if (dt) {
      const d = new Date(dt);
      if (!Number.isNaN(d.getTime())) return d.getTime();
    }

    const tsAttr =
      msg.getAttribute("data-ts") ||
      msg.getAttribute("data-message-ts") ||
      msg.getAttribute("data-message-id");

    if (tsAttr && /^\d{10}(\.\d+)?$/.test(tsAttr)) {
      const sec = parseFloat(tsAttr);
      if (!Number.isNaN(sec)) return Math.floor(sec * 1000);
    }

    return fallbackTsMs || null;
  };

  const extractText = (msg) => {
    let nodes = Array.from(msg.querySelectorAll('[data-qa="message-text"]'));
    if (!nodes.length) nodes = Array.from(msg.querySelectorAll(".c-message_kit__text, .c-message__body"));

    const parts = nodes.map((n) => (n.innerText || "").trim()).filter(Boolean);
    return parts.join("\n").trim();
  };

  const captureVisible = () => {
    const msgs = Array.from(document.querySelectorAll('[data-qa="message_container"]'));

    let lastUser = "";
    let lastTsMs = null;

    let added = 0;
    let minTsSeen = null;

    for (const msg of msgs) {
      if (signal.aborted) break;

      const user =
        pickFirstText(msg, [
          '[data-qa="message_sender"]',
          "a.c-message__sender_link",
          ".c-message__sender",
          ".c-message_kit__sender",
        ]) || lastUser || "Unknown";

      if (user && user !== "Unknown") lastUser = user;

      const tsMs = getTsMs(msg, lastTsMs);
      if (tsMs) lastTsMs = tsMs;

      const text = extractText(msg);
      if (!text) continue;

      if (!tsMs) continue;

      if (tsMs < startBoundary.getTime() || tsMs > now.getTime()) {
        minTsSeen = minTsSeen === null ? tsMs : Math.min(minTsSeen, tsMs);
        continue;
      }

      const key = `${tsMs}|${user}|${text}`;
      if (!STATE.records.has(key)) {
        STATE.records.set(key, { user, text, tsMs });
        added++;
      }

      minTsSeen = minTsSeen === null ? tsMs : Math.min(minTsSeen, tsMs);
    }

    return { visible: msgs.length, added, minTsSeen };
  };

  const downloadNow = () => {
    const rows = Array.from(STATE.records.values());
    rows.sort((a, b) => (a.tsMs || 0) - (b.tsMs || 0));
    const output = rows.map((r) => `${r.user}: ${r.text}`).join("\n\n");

    try { copy(output); } catch {}

    const name = `${CONFIG.filePrefix}_${new Date().toISOString().slice(0, 10)}.txt`;
    const blob = new Blob([output], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    console.log(`Downloaded ${name}. Messages saved: ${rows.length}`);
  };

  const stopAndDownload = () => {
    if (!STATE.running) return;
    STATE.stopRequested = true;
    STATE.running = false;
    controller.abort();
    setTimeout(() => {
      try { captureVisible(); } catch {}
      downloadNow();
      console.log("Stopped.");
    }, 0);
  };

  window.slackDump = {
    running: true,
    stop: stopAndDownload,
    status: () => ({
      running: STATE.running,
      steps: STATE.steps,
      saved: STATE.records.size,
      startBoundaryLocal: startBoundary.toString(),
      weekStartsMonday: WEEK_STARTS_MONDAY,
    }),
    restoreStop: () => {
      if (nativeWindowStop) window.stop = nativeWindowStop;
      console.log("Restored native window.stop().");
    },
  };

  window.stop = () => stopAndDownload();

  console.log(`Slack dump started for THIS WEEK only. Start: ${startBoundary.toString()}`);
  console.log("Type stop() any time to stop and download. Also works: slackDump.stop()");

  (async () => {
    const scroller = findScroller();
    if (!scroller) {
      console.log("Could not find message scroller. Click inside the message list and run again.");
      return;
    }

    const endAt = Date.now() + CONFIG.maxRunMs;

    while (!signal.aborted && Date.now() < endAt) {
      const { visible, added, minTsSeen } = captureVisible();
      const before = scroller.scrollTop;

      if (typeof scroller.scrollBy === "function") scroller.scrollBy(0, -CONFIG.scrollPx);
      else scroller.scrollTop = Math.max(0, before - CONFIG.scrollPx);

      scroller.dispatchEvent(new Event("scroll", { bubbles: true }));
      const after = scroller.scrollTop;

      STATE.steps++;

      if (minTsSeen !== null && minTsSeen < startBoundary.getTime()) STATE.olderStreak++;
      else STATE.olderStreak = 0;

      console.log(
        `Step ${STATE.steps} | visible=${visible} | added=${added} | saved=${STATE.records.size} | scrollTop ${before} -> ${after}`
      );

      if ((before === 0 && after === 0) || STATE.olderStreak >= CONFIG.olderStreakToStop) break;

      await sleep(CONFIG.stepWaitMs);
    }

    if (!signal.aborted) stopAndDownload();
  })();
})();
