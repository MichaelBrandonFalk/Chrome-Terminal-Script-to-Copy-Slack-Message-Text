(() => {
  // Stop any prior run
  if (window.__slackDumpCtl && window.__slackDumpCtl.running) {
    try { window.__slackDumpCtl.stop(); } catch {}
  }

  const CONFIG = {
    runMs: 6 * 60 * 1000,
    stepWaitMs: 850,
    scrollPx: 1400,
    filePrefix: "slack_today",
    stopAfterNoNewAdds: 10, // stop if we keep seeing nothing new
  };

  const STATE = {
    running: true,
    stopRequested: false,
    steps: 0,
    noNewAddsStreak: 0,
    records: new Map(), // key -> line
  };

  const controller = new AbortController();
  const { signal } = controller;

  const sleep = (ms) =>
    Promise.race([
      new Promise((r) => setTimeout(r, ms)),
      new Promise((r) => signal.addEventListener("abort", r, { once: true })),
    ]);

  const sanitize = (s) => (s || "").replace(/\s+/g, " ").trim();

  const pickFirstText = (root, selectors) => {
    for (const sel of selectors) {
      const el = root.querySelector(sel);
      const txt = sanitize(el && (el.textContent || el.innerText));
      if (txt) return txt;
    }
    return "";
  };

  const findScroller = () => {
    const candidates = Array.from(document.querySelectorAll('[data-qa="slack_kit_scrollbar"]'));
    let best = null;
    let bestScore = -1;

    for (const el of candidates) {
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      const scrollable = el.scrollHeight > el.clientHeight + 5;
      const score = (scrollable ? 1000 : 0) + count;
      if (score > bestScore) { best = el; bestScore = score; }
    }
    if (best) return best;

    // Fallback: any scrollable container with messages
    const divs = Array.from(document.querySelectorAll("div"));
    best = null;
    bestScore = -1;
    for (const el of divs) {
      if (el.scrollHeight <= el.clientHeight + 50) continue;
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      if (!count) continue;
      if (count > bestScore) { best = el; bestScore = count; }
    }
    return best;
  };

  const getTimestampLabel = (msg) => {
    // Try common timestamp containers and fall back to any element with aria-label containing "at"
    const tsEl =
      msg.querySelector('a.c-timestamp[aria-label]') ||
      msg.querySelector('[data-qa="message_timestamp"][aria-label]') ||
      msg.querySelector('[aria-label*=" at "]');

    const label = tsEl && tsEl.getAttribute("aria-label");
    return sanitize(label);
  };

  const isToday = (tsLabel) => {
    const t = (tsLabel || "").toLowerCase();
    return t.startsWith("today ") || t.includes("today at ");
  };

  const extractText = (msg) => {
    let nodes = Array.from(msg.querySelectorAll('[data-qa="message-text"]'));
    if (!nodes.length) nodes = Array.from(msg.querySelectorAll(".c-message_kit__text, .c-message__body"));
    const parts = nodes.map((n) => (n.innerText || "").trim()).filter(Boolean);
    return parts.join("\n").trim();
  };

  const captureVisible = () => {
    const msgs = Array.from(document.querySelectorAll('[data-qa="message_container"]'));

    let lastUser = "";
    let added = 0;

    for (const msg of msgs) {
      if (signal.aborted) break;

      const tsLabel = getTimestampLabel(msg);
      if (!isToday(tsLabel)) continue;

      const user =
        pickFirstText(msg, [
          '[data-qa="message_sender"]',
          "a.c-message__sender_link",
          ".c-message__sender",
          ".c-message_kit__sender",
        ]) || lastUser || "Unknown";

      if (user && user !== "Unknown") lastUser = user;

      const text = extractText(msg);
      if (!text) continue;

      const idHint =
        msg.getAttribute("data-message-id") ||
        msg.getAttribute("data-item-key") ||
        msg.id ||
        "";

      const key = idHint ? `ID:${idHint}` : `K:${tsLabel}|${user}|${text}`;
      if (!STATE.records.has(key)) {
        STATE.records.set(key, `${user}: ${text}`);
        added++;
      }
    }

    return { added, total: STATE.records.size, visible: msgs.length };
  };

  const downloadNow = () => {
    const lines = Array.from(STATE.records.values());
    const output = lines.join("\n\n");

    try { copy(output); } catch {}

    const name = `${CONFIG.filePrefix}_${new Date().toISOString().slice(0, 10)}.txt`;
    const blob = new Blob([output], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    console.log(`Downloaded ${name}. Saved messages: ${lines.length}`);
  };

  const stopAndDownload = () => {
    if (!STATE.running) return;
    STATE.running = false;
    STATE.stopRequested = true;
    controller.abort();
    setTimeout(() => {
      try { captureVisible(); } catch {}
      downloadNow();
      console.log("Stopped.");
    }, 0);
  };

  window.__slackDumpCtl = { running: true, stop: stopAndDownload };
  window.slackDumpStop = stopAndDownload;

  console.log("Slack dump started: TODAY only.");
  console.log("To stop early and download: slackDumpStop()");

  (async () => {
    const scroller = findScroller();
    if (!scroller) {
      console.log("Could not find message scroller. Click inside the message list and run again.");
      return;
    }

    const endAt = Date.now() + CONFIG.runMs;

    while (!signal.aborted && Date.now() < endAt) {
      const before = scroller.scrollTop;

      const { added, total, visible } = captureVisible();
      STATE.steps++;

      if (added === 0) STATE.noNewAddsStreak++;
      else STATE.noNewAddsStreak = 0;

      if (typeof scroller.scrollBy === "function") scroller.scrollBy(0, -CONFIG.scrollPx);
      else scroller.scrollTop = Math.max(0, before - CONFIG.scrollPx);

      scroller.dispatchEvent(new Event("scroll", { bubbles: true }));
      const after = scroller.scrollTop;

      console.log(`Step ${STATE.steps} | visible=${visible} | added=${added} | saved=${total} | scrollTop ${before} -> ${after}`);

      if ((before === 0 && after === 0) || STATE.noNewAddsStreak >= CONFIG.stopAfterNoNewAdds) break;

      await sleep(CONFIG.stepWaitMs);
    }

    if (!signal.aborted) stopAndDownload();
  })();
})();
