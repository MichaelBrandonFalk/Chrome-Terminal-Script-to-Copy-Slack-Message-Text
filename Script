(() => {
  // If an old run is active, stop it first.
  if (window.slackDump && window.slackDump.running) {
    console.log("Found an existing slackDump run. Stopping it now...");
    window.slackDump.stop();
  }

  const CONFIG = {
    runMs: 5 * 60 * 1000,   // auto-stop after 5 minutes
    stepWaitMs: 800,        // wait for Slack to load messages after scroll
    scrollPx: 1400,         // how far to scroll each step
    filePrefix: "slack_channel_user_text",
  };

  const STATE = {
    running: true,
    stopRequested: false,
    startedAt: Date.now(),
    steps: 0,
    saved: 0,
    lastProgressLogAt: 0,
  };

  // Preserve native window.stop (browser stop-loading) so you can restore it later.
  const nativeWindowStop = window.stop && window.stop.bind(window);
  window.__nativeWindowStop = nativeWindowStop;

  // Abort controller for immediate stops (no waiting a whole sleep).
  const controller = new AbortController();
  const { signal } = controller;

  const sleep = (ms) =>
    Promise.race([
      new Promise((r) => setTimeout(r, ms)),
      new Promise((r) => signal.addEventListener("abort", r, { once: true })),
    ]);

  // Data stores (persist across runs if you want)
  const STORE = window.__slackDumpStore || {
    // key -> { user, text }
    records: new Map(),
  };
  window.__slackDumpStore = STORE;

  function sanitize(s) {
    return (s || "").replace(/\s+/g, " ").trim();
  }

  function guessFileName() {
    const t = sanitize(document.title);
    const safe = t.replace(/[^\w\-]+/g, "_").replace(/_+/g, "_").slice(0, 80) || "channel";
    return `${CONFIG.filePrefix}_${safe}_${new Date().toISOString().slice(0, 10)}.txt`;
  }

  function findScroller() {
    // Slack commonly uses these for scroll panes. We pick the one with most message containers.
    const candidates = Array.from(document.querySelectorAll('[data-qa="slack_kit_scrollbar"]'));
    let best = null;
    let bestScore = -1;

    for (const el of candidates) {
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      const scrollable = el.scrollHeight > el.clientHeight + 5;
      const score = (scrollable ? 1000 : 0) + count;
      if (score > bestScore) {
        best = el;
        bestScore = score;
      }
    }

    if (best) return best;

    // Fallback: any scrollable element containing messages.
    const divs = Array.from(document.querySelectorAll("div"));
    best = null;
    bestScore = -1;

    for (const el of divs) {
      if (el.scrollHeight <= el.clientHeight + 50) continue;
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      if (!count) continue;
      if (count > bestScore) {
        best = el;
        bestScore = count;
      }
    }

    return best;
  }

  function pickFirstText(root, selectors) {
    for (const sel of selectors) {
      const el = root.querySelector(sel);
      const txt = sanitize(el && (el.textContent || el.innerText));
      if (txt) return txt;
    }
    return "";
  }

  function getMessageIdHint(msg) {
    // Prefer stable IDs if present.
    return (
      msg.getAttribute("data-message-id") ||
      msg.getAttribute("data-item-key") ||
      msg.id ||
      ""
    );
  }

  function extractTextFromMessage(msg) {
    // Primary selector for Slack message text
    let nodes = Array.from(msg.querySelectorAll('[data-qa="message-text"]'));

    // Fallbacks for UI variations
    if (!nodes.length) {
      nodes = Array.from(msg.querySelectorAll(".c-message_kit__text, .c-message__body"));
    }

    const parts = nodes
      .map((n) => sanitize(n.innerText))
      .filter(Boolean);

    return parts.join("\n").trim();
  }

  function captureVisible() {
    const msgs = Array.from(document.querySelectorAll('[data-qa="message_container"]'));

    // Fill down usernames for continuation messages in the current viewport.
    let lastUser = "";

    let added = 0;
    for (const msg of msgs) {
      if (signal.aborted) break;

      const user =
        pickFirstText(msg, [
          '[data-qa="message_sender"]',
          "a.c-message__sender_link",
          ".c-message__sender",
          ".c-message_kit__sender",
        ]) || lastUser || "Unknown";

      if (user && user !== "Unknown") lastUser = user;

      const text = extractTextFromMessage(msg);
      if (!text) continue;

      const idHint = getMessageIdHint(msg);
      const key = idHint ? `ID:${idHint}` : `UT:${user}\n${text}`;

      if (!STORE.records.has(key)) {
        STORE.records.set(key, { user, text });
        added++;
      }
    }

    STATE.saved = STORE.records.size;
    return { visible: msgs.length, added };
  }

  function scrollUp(scroller) {
    const before = scroller.scrollTop;

    // Prefer element scrolling APIs when available.
    if (typeof scroller.scrollBy === "function") {
      scroller.scrollBy(0, -CONFIG.scrollPx);
    } else {
      scroller.scrollTop = Math.max(0, before - CONFIG.scrollPx);
    }

    // Nudge Slack listeners (some builds respond better with events)
    scroller.dispatchEvent(new Event("scroll", { bubbles: true }));

    return { before, after: scroller.scrollTop };
  }

  function buildOutput() {
    // Keep insertion order from Map.
    const rows = Array.from(STORE.records.values()).map((r) => `${r.user}: ${r.text}`);
    return rows.join("\n\n");
  }

  function downloadNow() {
    const output = buildOutput();

    try {
      copy(output);
      console.log(`Copied ${STORE.records.size} messages to clipboard (may truncate if huge).`);
    } catch (e) {
      console.log("Clipboard copy failed or too large, downloading file instead.");
    }

    const blob = new Blob([output], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = guessFileName();
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    console.log(`Downloaded. Total saved messages: ${STORE.records.size}`);
  }

  function stopAndDownload() {
    if (!STATE.running) return;
    STATE.stopRequested = true;
    STATE.running = false;
    controller.abort(); // breaks sleeps immediately
    // Give the current call stack a moment to unwind, then download.
    setTimeout(() => {
      try {
        captureVisible();
      } catch {}
      downloadNow();
      console.log("Stopped.");
    }, 0);
  }

  // Public controls
  window.slackDump = {
    running: true,
    stop: stopAndDownload,
    download: downloadNow,
    status: () => ({
      running: STATE.running,
      stopRequested: STATE.stopRequested,
      seconds: Math.round((Date.now() - STATE.startedAt) / 1000),
      steps: STATE.steps,
      saved: STORE.records.size,
    }),
    restoreStop: () => {
      if (nativeWindowStop) window.stop = nativeWindowStop;
      console.log("Restored native window.stop().");
    },
    reset: () => {
      STORE.records.clear();
      console.log("Cleared saved messages.");
    },
  };

  // Make "stop()" work by overriding window.stop safely.
  // You can restore via slackDump.restoreStop().
  window.stop = () => stopAndDownload();

  console.log("slackDump started.");
  console.log("Type stop() to stop and download.");
  console.log("Backup controls: slackDump.stop(), slackDump.status(), slackDump.download(), slackDump.restoreStop()");
  console.log("Tip: click inside the message list first if scrolling does nothing.");

  (async () => {
    const scroller = findScroller();
    if (!scroller) {
      console.log("Could not find Slack message scroller. Click inside the message list and run again.");
      return;
    }

    const endAt = Date.now() + CONFIG.runMs;

    while (!signal.aborted && Date.now() < endAt) {
      const { visible, added } = captureVisible();
      const { before, after } = scrollUp(scroller);

      STATE.steps++;

      const now = Date.now();
      if (now - STATE.lastProgressLogAt > 1500) {
        console.log(
          `Step ${STATE.steps} | visible=${visible} | added=${added} | saved=${STORE.records.size} | scrollTop ${before} -> ${after}`
        );
        STATE.lastProgressLogAt = now;
      }

      // If we hit the top and cannot move, end early.
      if (before === 0 && after === 0) break;

      await sleep(CONFIG.stepWaitMs);
    }

    if (!signal.aborted) {
      stopAndDownload();
    }
  })();
})();
