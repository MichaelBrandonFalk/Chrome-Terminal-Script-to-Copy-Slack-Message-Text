(() => {
  // Set to "today" or "week"
  const MODE = "today";

  // Stop any prior run
  if (window.__slackDumpCtl && window.__slackDumpCtl.running) {
    try { window.__slackDumpCtl.stop(); } catch {}
  }

  const CONFIG = {
    runMs: MODE === "today" ? 6 * 60 * 1000 : 7 * 60 * 1000,
    stepWaitMs: 850,
    scrollPx: 1400,
    stopAfterNoNewAdds: MODE === "today" ? 12 : 18,
    filePrefix: MODE === "today" ? "slack_today_ordered" : "slack_this_week_ordered",
  };

  const STATE = {
    running: true,
    steps: 0,
    noNewAddsStreak: 0,
    seq: 0,
    // key -> { tsMs, seq, user, text }
    records: new Map(),
  };

  const controller = new AbortController();
  const { signal } = controller;

  const sleep = (ms) =>
    Promise.race([
      new Promise((r) => setTimeout(r, ms)),
      new Promise((r) => signal.addEventListener("abort", r, { once: true })),
    ]);

  const sanitize = (s) => (s || "").replace(/\s+/g, " ").trim();

  const pickFirstText = (root, selectors) => {
    for (const sel of selectors) {
      const el = root.querySelector(sel);
      const txt = sanitize(el && (el.textContent || el.innerText));
      if (txt) return txt;
    }
    return "";
  };

  const findScroller = () => {
    const candidates = Array.from(document.querySelectorAll('[data-qa="slack_kit_scrollbar"]'));
    let best = null;
    let bestScore = -1;

    for (const el of candidates) {
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      const scrollable = el.scrollHeight > el.clientHeight + 5;
      const score = (scrollable ? 1000 : 0) + count;
      if (score > bestScore) { best = el; bestScore = score; }
    }
    if (best) return best;

    const divs = Array.from(document.querySelectorAll("div"));
    best = null;
    bestScore = -1;
    for (const el of divs) {
      if (el.scrollHeight <= el.clientHeight + 50) continue;
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      if (!count) continue;
      if (count > bestScore) { best = el; bestScore = count; }
    }
    return best;
  };

  const extractText = (msg) => {
    let nodes = Array.from(msg.querySelectorAll('[data-qa="message-text"]'));
    if (!nodes.length) nodes = Array.from(msg.querySelectorAll(".c-message_kit__text, .c-message__body"));
    const parts = nodes.map((n) => (n.innerText || "").trim()).filter(Boolean);
    return parts.join("\n").trim();
  };

  const getUsername = (msg, lastUser) => {
    return (
      pickFirstText(msg, [
        '[data-qa="message_sender"]',
        "a.c-message__sender_link",
        ".c-message__sender",
        ".c-message_kit__sender",
      ]) || lastUser || "Unknown"
    );
  };

  // Parse Slack permalink timestamp: /p1708291234567890
  // This encodes seconds + microseconds. Convert to ms.
  const parseTsFromPermalink = (href) => {
    if (!href) return null;
    const m = href.match(/\/p(\d{10,})(?:\?|$)/);
    if (!m) return null;

    const digits = m[1];
    // Common length is 16: 10 sec + 6 micros
    // Also seen: 15, 17 depending on formatting.
    const sec = parseInt(digits.slice(0, 10), 10);
    if (!Number.isFinite(sec)) return null;

    let micros = 0;
    const rest = digits.slice(10);
    if (rest) {
      // Keep only first 6 digits as micros (pad or truncate)
      const microStr = (rest + "000000").slice(0, 6);
      micros = parseInt(microStr, 10);
      if (!Number.isFinite(micros)) micros = 0;
    }
    return sec * 1000 + Math.floor(micros / 1000);
  };

  const getMessageTsMs = (msg) => {
    // Prefer timestamp/permalink anchor
    const a =
      msg.querySelector('a.c-timestamp[href*="/p"]') ||
      msg.querySelector('a[href*="/archives/"][href*="/p"]') ||
      msg.querySelector('a[href*="/p"]');

    const href = a && a.getAttribute("href");
    const tsMs = parseTsFromPermalink(href);

    if (tsMs != null) return tsMs;

    // Fallback: some builds include numeric ts attributes
    const attr =
      msg.getAttribute("data-message-ts") ||
      msg.getAttribute("data-ts") ||
      "";
    if (attr && /^\d{10}(\.\d+)?$/.test(attr)) {
      const sec = parseFloat(attr);
      if (Number.isFinite(sec)) return Math.floor(sec * 1000);
    }

    return null;
  };

  const startOfTodayMs = () => {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    return d.getTime();
  };

  const startOfWeekMondayMs = () => {
    const d = new Date();
    const day = d.getDay(); // 0 Sun..6 Sat
    const offset = (day + 6) % 7; // Monday-based
    d.setDate(d.getDate() - offset);
    d.setHours(0, 0, 0, 0);
    return d.getTime();
  };

  const inScope = (tsMs) => {
    if (tsMs == null) return false;
    const nowMs = Date.now();
    if (MODE === "today") return tsMs >= startOfTodayMs() && tsMs <= nowMs;
    return tsMs >= startOfWeekMondayMs() && tsMs <= nowMs;
  };

  const captureVisible = () => {
    const msgs = Array.from(document.querySelectorAll('[data-qa="message_container"]'));

    let lastUser = "";
    let added = 0;

    for (const msg of msgs) {
      if (signal.aborted) break;

      const tsMs = getMessageTsMs(msg);
      if (!inScope(tsMs)) continue;

      const user = getUsername(msg, lastUser);
      if (user && user !== "Unknown") lastUser = user;

      const text = extractText(msg);
      if (!text) continue;

      const idHint =
        msg.getAttribute("data-message-id") ||
        msg.getAttribute("data-item-key") ||
        msg.id ||
        "";

      const key = idHint ? `ID:${idHint}` : `K:${tsMs}|${user}|${text}`;

      if (!STATE.records.has(key)) {
        STATE.seq += 1;
        STATE.records.set(key, { tsMs, seq: STATE.seq, user, text });
        added++;
      }
    }

    return { added, total: STATE.records.size, visible: msgs.length };
  };

  const buildOrderedOutput = () => {
    const rows = Array.from(STATE.records.values())
      .sort((a, b) => (a.tsMs - b.tsMs) || (a.seq - b.seq));
    return rows.map((r) => `${r.user}: ${r.text}`).join("\n\n");
  };

  const downloadNow = () => {
    const output = buildOrderedOutput();
    try { copy(output); } catch {}

    const name = `${CONFIG.filePrefix}_${new Date().toISOString().slice(0, 10)}.txt`;
    const blob = new Blob([output], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    console.log(`Downloaded ${name}. Saved messages: ${STATE.records.size}`);
  };

  const stopAndDownload = () => {
    if (!STATE.running) return;
    STATE.running = false;
    controller.abort();
    setTimeout(() => {
      try { captureVisible(); } catch {}
      downloadNow();
      console.log("Stopped.");
    }, 0);
  };

  window.__slackDumpCtl = { running: true, stop: stopAndDownload };
  window.slackDumpStop = stopAndDownload;

  console.log(`Slack dump started. MODE=${MODE}. Ordered output using permalink timestamps.`);
  console.log("Stop early and download: slackDumpStop()");

  (async () => {
    const scroller = findScroller();
    if (!scroller) {
      console.log("Could not find message scroller. Click inside the message list and run again.");
      return;
    }

    const endAt = Date.now() + CONFIG.runMs;

    while (!signal.aborted && Date.now() < endAt) {
      const before = scroller.scrollTop;

      const { added, total, visible } = captureVisible();
      STATE.steps++;

      if (added === 0) STATE.noNewAddsStreak++;
      else STATE.noNewAddsStreak = 0;

      if (typeof scroller.scrollBy === "function") scroller.scrollBy(0, -CONFIG.scrollPx);
      else scroller.scrollTop = Math.max(0, before - CONFIG.scrollPx);

      scroller.dispatchEvent(new Event("scroll", { bubbles: true }));
      const after = scroller.scrollTop;

      console.log(`Step ${STATE.steps} | visible=${visible} | added=${added} | saved=${total} | scrollTop ${before} -> ${after}`);

      if ((before === 0 && after === 0) || STATE.noNewAddsStreak >= CONFIG.stopAfterNoNewAdds) break;

      await sleep(CONFIG.stepWaitMs);
    }

    if (!signal.aborted) stopAndDownload();
  })();
})();
