(() => {
  // Set to "today" or "week"
  const MODE = "today";

  // Stop any prior run
  if (window.__slackDumpCtl && window.__slackDumpCtl.running) {
    try { window.__slackDumpCtl.stop(); } catch {}
  }

  const CONFIG = {
    runMs: MODE === "today" ? 6 * 60 * 1000 : 7 * 60 * 1000,
    stepWaitMs: 850,
    scrollPx: 1400,
    filePrefix: MODE === "today" ? "slack_today_ordered" : "slack_this_week_ordered",
    stopAfterNoNewAdds: MODE === "today" ? 10 : 14,
  };

  const STATE = {
    running: true,
    steps: 0,
    noNewAddsStreak: 0,
    seq: 0,
    // key -> { tsMs, seq, user, text }
    records: new Map(),
  };

  const controller = new AbortController();
  const { signal } = controller;

  const sleep = (ms) =>
    Promise.race([
      new Promise((r) => setTimeout(r, ms)),
      new Promise((r) => signal.addEventListener("abort", r, { once: true })),
    ]);

  const sanitize = (s) => (s || "").replace(/\s+/g, " ").trim();

  const pickFirstText = (root, selectors) => {
    for (const sel of selectors) {
      const el = root.querySelector(sel);
      const txt = sanitize(el && (el.textContent || el.innerText));
      if (txt) return txt;
    }
    return "";
  };

  const findScroller = () => {
    const candidates = Array.from(document.querySelectorAll('[data-qa="slack_kit_scrollbar"]'));
    let best = null;
    let bestScore = -1;

    for (const el of candidates) {
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      const scrollable = el.scrollHeight > el.clientHeight + 5;
      const score = (scrollable ? 1000 : 0) + count;
      if (score > bestScore) { best = el; bestScore = score; }
    }
    if (best) return best;

    const divs = Array.from(document.querySelectorAll("div"));
    best = null;
    bestScore = -1;
    for (const el of divs) {
      if (el.scrollHeight <= el.clientHeight + 50) continue;
      const count = el.querySelectorAll?.('[data-qa="message_container"]').length || 0;
      if (!count) continue;
      if (count > bestScore) { best = el; bestScore = count; }
    }
    return best;
  };

  const extractText = (msg) => {
    let nodes = Array.from(msg.querySelectorAll('[data-qa="message-text"]'));
    if (!nodes.length) nodes = Array.from(msg.querySelectorAll(".c-message_kit__text, .c-message__body"));
    const parts = nodes.map((n) => (n.innerText || "").trim()).filter(Boolean);
    return parts.join("\n").trim();
  };

  const getUsername = (msg, lastUser) => {
    const user =
      pickFirstText(msg, [
        '[data-qa="message_sender"]',
        "a.c-message__sender_link",
        ".c-message__sender",
        ".c-message_kit__sender",
      ]) || lastUser || "Unknown";
    return user;
  };

  const getTimestampLabel = (msg) => {
    const tsEl =
      msg.querySelector('a.c-timestamp[aria-label]') ||
      msg.querySelector('[data-qa="message_timestamp"][aria-label]') ||
      msg.querySelector('a[aria-label*=" at "]') ||
      msg.querySelector('[aria-label*=" at "]');

    return sanitize(tsEl && tsEl.getAttribute("aria-label"));
  };

  const weekdayIndex = (name) => {
    const n = name.toLowerCase().replace(",", "");
    const map = {
      sunday: 0, monday: 1, tuesday: 2, wednesday: 3,
      thursday: 4, friday: 5, saturday: 6
    };
    return Object.prototype.hasOwnProperty.call(map, n) ? map[n] : null;
  };

  const parseTimeTo24h = (timeStr) => {
    // Accepts "9:41 AM" or "9 AM"
    const m = timeStr.match(/^(\d{1,2})(?::(\d{2}))?\s*([AP]M)$/i);
    if (!m) return null;

    let hh = parseInt(m[1], 10);
    const mm = m[2] ? parseInt(m[2], 10) : 0;
    const ap = m[3].toUpperCase();

    if (ap === "AM") {
      if (hh === 12) hh = 0;
    } else {
      if (hh !== 12) hh += 12;
    }
    return { hh, mm };
  };

  const startOfToday = () => {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    return d;
  };

  const startOfWeekMonday = () => {
    const d = new Date();
    const day = d.getDay(); // 0 Sun..6 Sat
    const offset = (day + 6) % 7; // monday-based
    d.setDate(d.getDate() - offset);
    d.setHours(0, 0, 0, 0);
    return d;
  };

  const parseSlackAriaLabelToMs = (label) => {
    // Expected like:
    // "Today at 9:41 AM"
    // "Yesterday at 3:12 PM"
    // "Monday at 10:05 AM"
    if (!label) return null;

    const lower = label.toLowerCase();
    const parts = lower.split(" at ");
    if (parts.length < 2) return null;

    const dayPartRaw = parts[0].trim();
    const timePartRaw = parts.slice(1).join(" at ").trim().toUpperCase();

    const tm = parseTimeTo24h(timePartRaw);
    if (!tm) return null;

    const now = new Date();
    let base = new Date(now);
    base.setHours(0, 0, 0, 0);

    if (dayPartRaw === "today") {
      // base is today
    } else if (dayPartRaw === "yesterday") {
      base.setDate(base.getDate() - 1);
    } else {
      const w = weekdayIndex(dayPartRaw);
      if (w === null) return null;

      // Map weekday label to the most recent occurrence in the current week window.
      // If it says "Monday" and today is Thursday, we use this week's Monday.
      // If today is Monday and label says "Sunday", that likely refers to yesterday, so we go back 1 day.
      const todayW = base.getDay();
      let delta = todayW - w;
      if (delta < 0) delta += 7;
      base.setDate(base.getDate() - delta);
    }

    base.setHours(tm.hh, tm.mm, 0, 0);
    return base.getTime();
  };

  const inScope = (tsMs) => {
    if (tsMs == null) return false;
    const nowMs = Date.now();

    if (MODE === "today") {
      const start = startOfToday().getTime();
      return tsMs >= start && tsMs <= nowMs;
    }

    const start = startOfWeekMonday().getTime();
    return tsMs >= start && tsMs <= nowMs;
  };

  const captureVisible = () => {
    const msgs = Array.from(document.querySelectorAll('[data-qa="message_container"]'));

    let lastUser = "";
    let added = 0;

    for (const msg of msgs) {
      if (signal.aborted) break;

      const tsLabel = getTimestampLabel(msg);
      const tsMs = parseSlackAriaLabelToMs(tsLabel);
      if (!inScope(tsMs)) continue;

      const user = getUsername(msg, lastUser);
      if (user && user !== "Unknown") lastUser = user;

      const text = extractText(msg);
      if (!text) continue;

      const idHint =
        msg.getAttribute("data-message-id") ||
        msg.getAttribute("data-item-key") ||
        msg.id ||
        "";

      // Key uses tsLabel too to reduce collisions when idHint is missing
      const key = idHint ? `ID:${idHint}` : `K:${tsLabel}|${user}|${text}`;

      if (!STATE.records.has(key)) {
        STATE.seq += 1;
        STATE.records.set(key, { tsMs, seq: STATE.seq, user, text });
        added++;
      }
    }

    return { added, total: STATE.records.size, visible: msgs.length };
  };

  const buildOrderedOutput = () => {
    const rows = Array.from(STATE.records.values())
      .filter((r) => typeof r.tsMs === "number")
      .sort((a, b) => (a.tsMs - b.tsMs) || (a.seq - b.seq));

    return rows.map((r) => `${r.user}: ${r.text}`).join("\n\n");
  };

  const downloadNow = () => {
    const output = buildOrderedOutput();

    try { copy(output); } catch {}

    const name = `${CONFIG.filePrefix}_${new Date().toISOString().slice(0, 10)}.txt`;
    const blob = new Blob([output], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    console.log(`Downloaded ${name}. Saved messages: ${STATE.records.size}`);
  };

  const stopAndDownload = () => {
    if (!STATE.running) return;
    STATE.running = false;
    controller.abort();
    setTimeout(() => {
      try { captureVisible(); } catch {}
      downloadNow();
      console.log("Stopped.");
    }, 0);
  };

  window.__slackDumpCtl = { running: true, stop: stopAndDownload };
  window.slackDumpStop = stopAndDownload;

  console.log(`Slack dump started: ${MODE.toUpperCase()} with ordered output.`);
  console.log("Stop early and download: slackDumpStop()");

  (async () => {
    const scroller = findScroller();
    if (!scroller) {
      console.log("Could not find message scroller. Click inside the message list and run again.");
      return;
    }

    const endAt = Date.now() + CONFIG.runMs;

    while (!signal.aborted && Date.now() < endAt) {
      const before = scroller.scrollTop;

      const { added, total, visible } = captureVisible();
      STATE.steps++;

      if (added === 0) STATE.noNewAddsStreak++;
      else STATE.noNewAddsStreak = 0;

      if (typeof scroller.scrollBy === "function") scroller.scrollBy(0, -CONFIG.scrollPx);
      else scroller.scrollTop = Math.max(0, before - CONFIG.scrollPx);

      scroller.dispatchEvent(new Event("scroll", { bubbles: true }));
      const after = scroller.scrollTop;

      console.log(`Step ${STATE.steps} | visible=${visible} | added=${added} | saved=${total} | scrollTop ${before} -> ${after}`);

      if ((before === 0 && after === 0) || STATE.noNewAddsStreak >= CONFIG.stopAfterNoNewAdds) break;

      await sleep(CONFIG.stepWaitMs);
    }

    if (!signal.aborted) stopAndDownload();
  })();
})();
